{"ast":null,"code":"// SearchResultsContainer.s\n// previously known as ProcessSearchResults.is\nimport React from\"react\";import ShowSearchResults from'../components/Search/ShowSearchResults/ShowSearchResults';// Import Helper Component\n/* import FormatDate from './FormatDate'; */import FormatDate from'../components/Search/ProcessSearchResults/FormatDate';var SearchResultsContainer=function SearchResultsContainer(props){var output;var searchResults;if(props.unProcessedData){// deep copy the object\n// hmm, maybe we should not do this, because we are duplicating the same data\n// the only purpose for this, is that the data manipulation does not affect the original\n// passed object, so that the information (and its manipulations) flow down, \n// and there are not any sideefffects that flow up. Refactor? \nsearchResults=JSON.parse(JSON.stringify(props.unProcessedData));// add the treatment that each saloon offers\n// to each saloon object\naddTheTreatmentsOffered(searchResults);// add a count and next date to each treatment\naddCountAndNextToEachTreatment(searchResults);// shorten the title and description if they are more than \n// 100 or 200 chars respectively\nshortenTitleAndDescription(searchResults);output=searchResults;};if(props.clientCoordinates&&output){addDistanceToSaloon(props.clientCoordinates,output);}return/*#__PURE__*/React.createElement(ShowSearchResults,{processedSearchResults:output});};export default SearchResultsContainer;/* \n\n  HELPER FUNCTIONS\n  ******************************************************************************************************************************************************************************************************************************************************************************************************\n\n*/var addTheTreatmentsOffered=function addTheTreatmentsOffered(array){var newArray=array;// Loop through all of the saloons\nfor(var i=0;i<newArray.length;i++){var saloon=newArray[i];// Initiate an empty array\n// that will be used to store the treatment\n// that each saloon offers\nvar saloonTreatments=[];// Loop through each saloons array of timeslots\nfor(var y=0;y<saloon.timeslots.length;y++){// the timeslot is an array of objects\nvar timeslot=saloon.timeslots[y];// Loop through the array of treatments, that is housed in each timeslot\nvar _loop=function _loop(z){var treatment=timeslot.treatments[z];// check if the current looped through treatment's name is \n// already in the saloonTreatments array\nvar isIncluded=saloonTreatments.some(function(element){return element.name===treatment.name;});// if it is NOT already included\nif(!isIncluded){// then push it to the saloonTreatments array\nsaloonTreatments.push(treatment);};};for(var z=0;z<timeslot.treatments.length;z++){_loop(z);};};// add the new array of offered treatments to the saloon objects\nsaloon.treatmentsOffered=saloonTreatments;// reset the saloonTreatments array before initializing a new loop\nsaloonTreatments=[];};return newArray;};var addCountAndNextToEachTreatment=function addCountAndNextToEachTreatment(array){var manipulatedArray=array;// Loop through the saloons \nfor(var i=0;i<manipulatedArray.length;i++){var saloon=manipulatedArray[i];// Run an inner loop on the saloons treatmentsOffered array\n// so we basically take the treatments offered list and start another loop\nvar _loop2=function _loop2(j){var treatmentOffered=saloon.treatmentsOffered[j];// give the treatments offered object a new prop that will be\n// incremented for everytime we find a matching treatment in each timeslot\ntreatmentOffered.count=null;treatmentOffered.next=null;// Run another inner loop on the saloons timeslots array\n// The timeslots array contains an array of timeslot objects\n// that all have a treatment prop that has an array of \n// available treatments offered in that timeslot\nfor(var k=0;k<saloon.timeslots.length;k++){var timeslot=saloon.timeslots[k];// if the current timeslots treatment array contains the current treatmentOffered\nvar isIncluded=timeslot.treatments.some(function(element){return element.name===treatmentOffered.name;});// then add one to treatmentOffered.count\nif(isIncluded){treatmentOffered.count++;};// add the next available timeslot if not already set\nif(treatmentOffered.next===null){// here we could call a format date function that takes the date string\n// and converts it into our desired format: Onsdag d. 15 April kl 10:00\ntreatmentOffered.next=/*#__PURE__*/React.createElement(FormatDate,{dateString:timeslot.start});}};};for(var j=0;j<saloon.treatmentsOffered.length;j++){_loop2(j);};};};var addDistanceToSaloon=function addDistanceToSaloon(clientCoordinates,arrayOfSaloonObjects){var lat1=clientCoordinates.clientLatitude;/* console.log('clientCoordinates.clientLatitude = ' + clientCoordinates.clientLatitude); */var lon1=clientCoordinates.clientLongitude;/* console.log('clientCoordinates.clientLongitude = ' + clientCoordinates.clientLongitude); */ // loop through the array of saloon objects\nfor(var i=0;i<arrayOfSaloonObjects.length;i++){var currentSaloon=arrayOfSaloonObjects[i];var lat2=currentSaloon.latitude;/* console.log('currentSaloon.latitude = ' + currentSaloon.latitude); */var lon2=currentSaloon.longitude;/* console.log('currentSaloon.longitude = ' + currentSaloon.longitude); */currentSaloon.distance=getDistance(lat1,lon1,lat2,lon2);};};var getDistance=function getDistance(lat1,lon1,lat2,lon2){// return a zero if the two sets of coordinates are the same\nif(lat1===lat2&&lon1===lon2){return 0;}// magic:\nelse{var radlat1=Math.PI*lat1/180;var radlat2=Math.PI*lat2/180;var theta=lon1-lon2;var radtheta=Math.PI*theta/180;var dist=Math.sin(radlat1)*Math.sin(radlat2)+Math.cos(radlat1)*Math.cos(radlat2)*Math.cos(radtheta);if(dist>1){dist=1;}dist=Math.acos(dist);dist=dist*180/Math.PI;dist=dist*60*1.1515;dist=dist*1.609344;//km\ndist=Math.round(dist*10)/10;return dist;};};var shortenTitleAndDescription=function shortenTitleAndDescription(saloonArray){// Run an outer loop on the saloons\nfor(var i=0;i<saloonArray.length;i++){var saloon=saloonArray[i];// Run an inner loop on the treatments that each saloon offers\nfor(var j=0;j<saloon.treatmentsOffered.length;j++){var treatment=saloon.treatmentsOffered[j];if(treatment.name.length>100){treatment.name=shortenString(treatment.name,100);};if(treatment.description.length>250){treatment.description=shortenString(treatment.description,250);};};};};var shortenString=function shortenString(string,desiredLength){return string.slice(0,desiredLength)+\"[...]\";};","map":{"version":3,"sources":["/Users/nestos/Desktop/Code/glowspace/src/containers/SearchResultsContainer.js"],"names":["React","ShowSearchResults","FormatDate","SearchResultsContainer","props","output","searchResults","unProcessedData","JSON","parse","stringify","addTheTreatmentsOffered","addCountAndNextToEachTreatment","shortenTitleAndDescription","clientCoordinates","addDistanceToSaloon","array","newArray","i","length","saloon","saloonTreatments","y","timeslots","timeslot","z","treatment","treatments","isIncluded","some","element","name","push","treatmentsOffered","manipulatedArray","j","treatmentOffered","count","next","k","start","arrayOfSaloonObjects","lat1","clientLatitude","lon1","clientLongitude","currentSaloon","lat2","latitude","lon2","longitude","distance","getDistance","radlat1","Math","PI","radlat2","theta","radtheta","dist","sin","cos","acos","round","saloonArray","shortenString","description","string","desiredLength","slice"],"mappings":"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","sourcesContent":["// SearchResultsContainer.s\n\n// previously known as ProcessSearchResults.is\n\nimport React from \"react\";\n\nimport ShowSearchResults from '../components/Search/ShowSearchResults/ShowSearchResults';\n\n// Import Helper Component\n/* import FormatDate from './FormatDate'; */\nimport FormatDate from '../components/Search/ProcessSearchResults/FormatDate';\n\nconst SearchResultsContainer = props => {\n  \n  let output;\n  let searchResults;\n\n  if (props.unProcessedData) {\n\n    // deep copy the object\n    // hmm, maybe we should not do this, because we are duplicating the same data\n    // the only purpose for this, is that the data manipulation does not affect the original\n    // passed object, so that the information (and its manipulations) flow down, \n    // and there are not any sideefffects that flow up. Refactor? \n    searchResults = JSON.parse(JSON.stringify(props.unProcessedData))\n\n    // add the treatment that each saloon offers\n    // to each saloon object\n    addTheTreatmentsOffered(searchResults)\n\n    // add a count and next date to each treatment\n    addCountAndNextToEachTreatment(searchResults)\n\n    // shorten the title and description if they are more than \n    // 100 or 200 chars respectively\n    shortenTitleAndDescription(searchResults);\n\n    output = searchResults;\n  };\n\n  if (props.clientCoordinates && output) {\n    addDistanceToSaloon(props.clientCoordinates, output);\n  }\n\n  return(\n    <ShowSearchResults \n      processedSearchResults={output}\n    />\n  );\n};\n\n\nexport default SearchResultsContainer;\n\n\n/* \n\n  HELPER FUNCTIONS\n  ******************************************************************************************************************************************************************************************************************************************************************************************************\n\n*/\n\nconst addTheTreatmentsOffered = (array) => {\n  let newArray = array;\n\n  // Loop through all of the saloons\n  for (let i = 0; i < newArray.length; i++) {\n    const saloon = newArray[i];\n\n    // Initiate an empty array\n    // that will be used to store the treatment\n    // that each saloon offers\n    let saloonTreatments = [];\n\n    // Loop through each saloons array of timeslots\n    for (let y = 0; y < saloon.timeslots.length; y++) {\n\n      // the timeslot is an array of objects\n      let timeslot = saloon.timeslots[y];\n\n      // Loop through the array of treatments, that is housed in each timeslot\n      for (let z = 0; z < timeslot.treatments.length; z++) {\n        const treatment = timeslot.treatments[z];\n\n        // check if the current looped through treatment's name is \n        // already in the saloonTreatments array\n        let isIncluded = saloonTreatments.some( element => element.name === treatment.name);\n\n        // if it is NOT already included\n        if (!isIncluded) {\n          // then push it to the saloonTreatments array\n          saloonTreatments.push(treatment)    \n        };\n      };\n    };\n\n    // add the new array of offered treatments to the saloon objects\n    saloon.treatmentsOffered = saloonTreatments;\n\n    // reset the saloonTreatments array before initializing a new loop\n    saloonTreatments = [];\n  };\n\n  return newArray;\n};\n\nconst addCountAndNextToEachTreatment = (array) => {\n  let manipulatedArray = array;\n\n  // Loop through the saloons \n  for (let i = 0; i < manipulatedArray.length; i++) {\n    const saloon = manipulatedArray[i];\n\n    // Run an inner loop on the saloons treatmentsOffered array\n    // so we basically take the treatments offered list and start another loop\n    for (let j = 0; j < saloon.treatmentsOffered.length; j++) {\n      const treatmentOffered = saloon.treatmentsOffered[j];\n      // give the treatments offered object a new prop that will be\n      // incremented for everytime we find a matching treatment in each timeslot\n      treatmentOffered.count = null\n      treatmentOffered.next = null\n\n      // Run another inner loop on the saloons timeslots array\n      // The timeslots array contains an array of timeslot objects\n      // that all have a treatment prop that has an array of \n      // available treatments offered in that timeslot\n      for (let k = 0; k < saloon.timeslots.length; k++) {\n        const timeslot = saloon.timeslots[k];\n\n        // if the current timeslots treatment array contains the current treatmentOffered\n        let isIncluded = timeslot.treatments.some( element => element.name === treatmentOffered.name);\n  \n        // then add one to treatmentOffered.count\n        if (isIncluded) {\n          treatmentOffered.count++;\n        };\n\n        // add the next available timeslot if not already set\n        if (treatmentOffered.next === null) {\n          // here we could call a format date function that takes the date string\n          // and converts it into our desired format: Onsdag d. 15 April kl 10:00\n          treatmentOffered.next = <FormatDate dateString={timeslot.start} />\n        }\n      };\n    };\n  };\n};\n\nconst addDistanceToSaloon = (clientCoordinates, arrayOfSaloonObjects) => {\n\n  let lat1 = clientCoordinates.clientLatitude;\n  /* console.log('clientCoordinates.clientLatitude = ' + clientCoordinates.clientLatitude); */\n  \n  let lon1 = clientCoordinates.clientLongitude;\n  /* console.log('clientCoordinates.clientLongitude = ' + clientCoordinates.clientLongitude); */\n\n  // loop through the array of saloon objects\n  for (let i = 0; i < arrayOfSaloonObjects.length; i++) {\n    const currentSaloon = arrayOfSaloonObjects[i];\n\n    let lat2 = currentSaloon.latitude;\n    /* console.log('currentSaloon.latitude = ' + currentSaloon.latitude); */\n    \n    let lon2 = currentSaloon.longitude;\n    /* console.log('currentSaloon.longitude = ' + currentSaloon.longitude); */\n\n    currentSaloon.distance = getDistance(lat1, lon1, lat2, lon2);\n  };\n};\n\nconst getDistance = (lat1, lon1, lat2, lon2) => {\n  // return a zero if the two sets of coordinates are the same\n  if ((lat1 === lat2) && (lon1 === lon2)) {\n    return 0;\n  }\n  // magic:\n  else {\n    var radlat1 = Math.PI * lat1 / 180;\n    var radlat2 = Math.PI * lat2 / 180;\n    var theta = lon1 - lon2;\n    var radtheta = Math.PI * theta / 180;\n    var dist = Math.sin(radlat1) * Math.sin(radlat2) + Math.cos(radlat1) * Math.cos(radlat2) * Math.cos(radtheta);\n    if (dist > 1) {\n      dist = 1;\n    }\n    dist = Math.acos(dist);\n    dist = dist * 180 / Math.PI;\n    dist = dist * 60 * 1.1515;\n    dist = dist * 1.609344; //km\n    \n    dist = Math.round(dist * 10) / 10\n\n    return dist;\n  };\n};\n\nconst shortenTitleAndDescription = saloonArray => {\n  // Run an outer loop on the saloons\n  for (let i = 0; i < saloonArray.length; i++) {\n    const saloon = saloonArray[i];\n\n    // Run an inner loop on the treatments that each saloon offers\n    for (let j = 0; j < saloon.treatmentsOffered.length; j++) {\n      const treatment = saloon.treatmentsOffered[j];\n      \n      if (treatment.name.length > 100) {\n        treatment.name = shortenString(treatment.name, 100);\n      };\n\n      if (treatment.description.length > 250) {\n        treatment.description = shortenString(treatment.description, 250);\n      };\n    }; \n  };\n};\n\nconst shortenString = (string, desiredLength) => {\n  return string.slice(0, desiredLength) + \"[...]\";  \n};\n"]},"metadata":{},"sourceType":"module"}